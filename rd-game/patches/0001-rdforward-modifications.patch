diff -ruN /home/user/RDForward/rd-game/build/clean-src/com/mojang/rubydung/Player.java /home/user/RDForward/rd-game/src/main/java/com/mojang/rubydung/Player.java
--- a/com/mojang/rubydung/Player.java	2026-02-11 10:47:30.703519985 +0000
+++ b/com/mojang/rubydung/Player.java	2026-02-11 10:47:30.948519873 +0000
@@ -3,7 +3,7 @@
 import com.mojang.rubydung.level.Level;
 import com.mojang.rubydung.phys.AABB;
 import java.util.List;
-import org.lwjgl.input.Keyboard;
+import org.lwjgl.glfw.GLFW;
 
 public class Player {
     private Level level;
@@ -27,9 +27,9 @@
     }
 
     private void resetPos() {
-        float x = (float)Math.random() * this.level.width;
-        float y = this.level.depth + 10;
-        float z = (float)Math.random() * this.level.height;
+        float x = (float)Math.random() * (float)this.level.width;
+        float y = (float)(this.level.depth + 10);
+        float z = (float)Math.random() * (float)this.level.height;
         this.setPos(x, y, z);
     }
 
@@ -43,8 +43,8 @@
     }
 
     public void turn(float xo, float yo) {
-        this.yRot = (float)(this.yRot + xo * 0.15);
-        this.xRot = (float)(this.xRot - yo * 0.15);
+        this.yRot = (float)((double)this.yRot + (double)xo * 0.15);
+        this.xRot = (float)((double)this.xRot - (double)yo * 0.15);
         if (this.xRot < -90.0F) {
             this.xRot = -90.0F;
         }
@@ -54,38 +54,42 @@
         }
     }
 
+    private static boolean isKeyDown(int key) {
+        return GLFW.glfwGetKey(RubyDung.window, key) == GLFW.GLFW_PRESS;
+    }
+
     public void tick() {
         this.xo = this.x;
         this.yo = this.y;
         this.zo = this.z;
         float xa = 0.0F;
         float ya = 0.0F;
-        if (Keyboard.isKeyDown(19)) {
+        if (isKeyDown(GLFW.GLFW_KEY_R)) {
             this.resetPos();
         }
 
-        if (Keyboard.isKeyDown(200) || Keyboard.isKeyDown(17)) {
+        if (isKeyDown(GLFW.GLFW_KEY_UP) || isKeyDown(GLFW.GLFW_KEY_W)) {
             ya--;
         }
 
-        if (Keyboard.isKeyDown(208) || Keyboard.isKeyDown(31)) {
+        if (isKeyDown(GLFW.GLFW_KEY_DOWN) || isKeyDown(GLFW.GLFW_KEY_S)) {
             ya++;
         }
 
-        if (Keyboard.isKeyDown(203) || Keyboard.isKeyDown(30)) {
+        if (isKeyDown(GLFW.GLFW_KEY_LEFT) || isKeyDown(GLFW.GLFW_KEY_A)) {
             xa--;
         }
 
-        if (Keyboard.isKeyDown(205) || Keyboard.isKeyDown(32)) {
+        if (isKeyDown(GLFW.GLFW_KEY_RIGHT) || isKeyDown(GLFW.GLFW_KEY_D)) {
             xa++;
         }
 
-        if ((Keyboard.isKeyDown(57) || Keyboard.isKeyDown(219)) && this.onGround) {
+        if ((isKeyDown(GLFW.GLFW_KEY_SPACE) || isKeyDown(GLFW.GLFW_KEY_LEFT_SUPER)) && this.onGround) {
             this.yd = 0.12F;
         }
 
         this.moveRelative(xa, ya, this.onGround ? 0.02F : 0.005F);
-        this.yd = (float)(this.yd - 0.005);
+        this.yd = (float)((double)this.yd - 0.005);
         this.move(this.xd, this.yd, this.zd);
         this.xd *= 0.91F;
         this.yd *= 0.98F;
@@ -140,11 +144,11 @@
     public void moveRelative(float xa, float za, float speed) {
         float dist = xa * xa + za * za;
         if (!(dist < 0.01F)) {
-            dist = speed / (float)Math.sqrt(dist);
+            dist = speed / (float)Math.sqrt((double)dist);
             xa *= dist;
             za *= dist;
-            float sin = (float)Math.sin(this.yRot * Math.PI / 180.0);
-            float cos = (float)Math.cos(this.yRot * Math.PI / 180.0);
+            float sin = (float)Math.sin((double)this.yRot * Math.PI / 180.0);
+            float cos = (float)Math.cos((double)this.yRot * Math.PI / 180.0);
             this.xd += xa * cos - za * sin;
             this.zd += za * cos + xa * sin;
         }
diff -ruN /home/user/RDForward/rd-game/build/clean-src/com/mojang/rubydung/RubyDung.java /home/user/RDForward/rd-game/src/main/java/com/mojang/rubydung/RubyDung.java
--- a/com/mojang/rubydung/RubyDung.java	2026-02-11 10:47:30.706519984 +0000
+++ b/com/mojang/rubydung/RubyDung.java	2026-02-11 10:49:16.252471436 +0000
@@ -4,18 +4,17 @@
 import com.mojang.rubydung.level.Level;
 import com.mojang.rubydung.level.LevelRenderer;
 import java.io.IOException;
-import java.nio.Buffer;
 import java.nio.FloatBuffer;
 import java.nio.IntBuffer;
+import java.util.LinkedList;
+import java.util.Queue;
 import javax.swing.JOptionPane;
 import org.lwjgl.BufferUtils;
-import org.lwjgl.LWJGLException;
-import org.lwjgl.input.Keyboard;
-import org.lwjgl.input.Mouse;
-import org.lwjgl.opengl.Display;
-import org.lwjgl.opengl.DisplayMode;
+import org.lwjgl.glfw.GLFW;
+import org.lwjgl.glfw.GLFWErrorCallback;
+import org.lwjgl.opengl.GL;
 import org.lwjgl.opengl.GL11;
-import org.lwjgl.util.glu.GLU;
+import org.lwjgl.system.MemoryUtil;
 
 public class RubyDung implements Runnable {
     private static final boolean FULLSCREEN_MODE = false;
@@ -30,39 +29,111 @@
     private IntBuffer selectBuffer = BufferUtils.createIntBuffer(2000);
     private HitResult hitResult = null;
 
-    public void init() throws LWJGLException, IOException {
+    // GLFW window handle — accessible by Player for input polling
+    public static long window;
+
+    // Mouse delta tracking (GLFW cursor callback)
+    private double lastMouseX, lastMouseY;
+    private double mouseDX, mouseDY;
+    private boolean firstMouse = true;
+
+    // Mouse grab state — when ungrabbed, player can interact with the OS
+    private boolean mouseGrabbed = false;
+
+    // Event queues for GLFW callbacks
+    private final Queue<int[]> mouseEvents = new LinkedList<>();
+    private final Queue<int[]> keyEvents = new LinkedList<>();
+
+    public void init() throws IOException {
         int col = 920330;
         float fr = 0.5F;
         float fg = 0.8F;
         float fb = 1.0F;
-        this.fogColor.put(new float[]{(col >> 16 & 0xFF) / 255.0F, (col >> 8 & 0xFF) / 255.0F, (col & 0xFF) / 255.0F, 1.0F});
-        ((Buffer)this.fogColor).flip();
-        Display.setDisplayMode(new DisplayMode(1024, 768));
-        Display.create();
-        Keyboard.create();
-        Mouse.create();
-        this.width = Display.getDisplayMode().getWidth();
-        this.height = Display.getDisplayMode().getHeight();
-        GL11.glEnable(3553);
-        GL11.glShadeModel(7425);
+        this.fogColor.put(new float[]{(float)(col >> 16 & 0xFF) / 255.0F, (float)(col >> 8 & 0xFF) / 255.0F, (float)(col & 0xFF) / 255.0F, 1.0F});
+        this.fogColor.flip();
+
+        // Initialize GLFW
+        GLFWErrorCallback.createPrint(System.err).set();
+        if (!GLFW.glfwInit()) {
+            throw new IllegalStateException("Unable to initialize GLFW");
+        }
+
+        GLFW.glfwDefaultWindowHints();
+        GLFW.glfwWindowHint(GLFW.GLFW_VISIBLE, GLFW.GLFW_FALSE);
+        GLFW.glfwWindowHint(GLFW.GLFW_RESIZABLE, GLFW.GLFW_FALSE);
+
+        window = GLFW.glfwCreateWindow(1024, 768, "RubyDung", MemoryUtil.NULL, MemoryUtil.NULL);
+        if (window == MemoryUtil.NULL) {
+            throw new RuntimeException("Failed to create the GLFW window");
+        }
+
+        // Set up input callbacks
+        GLFW.glfwSetCursorPosCallback(window, (win, xpos, ypos) -> {
+            if (firstMouse) {
+                lastMouseX = xpos;
+                lastMouseY = ypos;
+                firstMouse = false;
+            }
+            mouseDX += xpos - lastMouseX;
+            mouseDY += ypos - lastMouseY;
+            lastMouseX = xpos;
+            lastMouseY = ypos;
+        });
+
+        GLFW.glfwSetMouseButtonCallback(window, (win, button, action, mods) -> {
+            mouseEvents.add(new int[]{button, action == GLFW.GLFW_PRESS ? 1 : 0});
+        });
+
+        GLFW.glfwSetKeyCallback(window, (win, key, scancode, action, mods) -> {
+            if (action == GLFW.GLFW_PRESS || action == GLFW.GLFW_RELEASE) {
+                keyEvents.add(new int[]{key, action == GLFW.GLFW_PRESS ? 1 : 0, mods});
+            }
+        });
+
+        GLFW.glfwMakeContextCurrent(window);
+        GL.createCapabilities();
+        GLFW.glfwSwapInterval(1);
+        GLFW.glfwShowWindow(window);
+
+        this.width = 1024;
+        this.height = 768;
+
+        GL11.glEnable(GL11.GL_TEXTURE_2D);
+        GL11.glShadeModel(GL11.GL_SMOOTH);
         GL11.glClearColor(fr, fg, fb, 0.0F);
         GL11.glClearDepth(1.0);
-        GL11.glEnable(2929);
-        GL11.glDepthFunc(515);
-        GL11.glMatrixMode(5889);
+        GL11.glEnable(GL11.GL_DEPTH_TEST);
+        GL11.glDepthFunc(GL11.GL_LEQUAL);
+        GL11.glMatrixMode(GL11.GL_PROJECTION);
         GL11.glLoadIdentity();
-        GL11.glMatrixMode(5888);
+        GL11.glMatrixMode(GL11.GL_MODELVIEW);
         this.level = new Level(256, 256, 64);
         this.levelRenderer = new LevelRenderer(this.level);
         this.player = new Player(this.level);
-        Mouse.setGrabbed(true);
+
+        // Grab the mouse cursor
+        grabMouse();
+    }
+
+    public void grabMouse() {
+        GLFW.glfwSetInputMode(window, GLFW.GLFW_CURSOR, GLFW.GLFW_CURSOR_DISABLED);
+        mouseGrabbed = true;
+        firstMouse = true;
+        mouseDX = 0;
+        mouseDY = 0;
+    }
+
+    public void ungrabMouse() {
+        GLFW.glfwSetInputMode(window, GLFW.GLFW_CURSOR, GLFW.GLFW_CURSOR_NORMAL);
+        mouseGrabbed = false;
     }
 
     public void destroy() {
         this.level.save();
-        Mouse.destroy();
-        Keyboard.destroy();
-        Display.destroy();
+        GLFW.glfwDestroyWindow(window);
+        GLFW.glfwTerminate();
+        GLFWErrorCallback ec = GLFW.glfwSetErrorCallback(null);
+        if (ec != null) ec.free();
     }
 
     @Override
@@ -78,7 +149,7 @@
         int frames = 0;
 
         try {
-            while (!Keyboard.isKeyDown(1) && !Display.isCloseRequested()) {
+            while (!GLFW.glfwWindowShouldClose(window)) {
                 this.timer.advanceTime();
 
                 for (int i = 0; i < this.timer.ticks; i++) {
@@ -117,44 +188,44 @@
     }
 
     private void setupCamera(float a) {
-        GL11.glMatrixMode(5889);
+        GL11.glMatrixMode(GL11.GL_PROJECTION);
         GL11.glLoadIdentity();
-        GLU.gluPerspective(70.0F, (float)this.width / this.height, 0.05F, 1000.0F);
-        GL11.glMatrixMode(5888);
+        gluPerspective(70.0F, (float)this.width / (float)this.height, 0.05F, 1000.0F);
+        GL11.glMatrixMode(GL11.GL_MODELVIEW);
         GL11.glLoadIdentity();
         this.moveCameraToPlayer(a);
     }
 
     private void setupPickCamera(float a, int x, int y) {
-        GL11.glMatrixMode(5889);
+        GL11.glMatrixMode(GL11.GL_PROJECTION);
         GL11.glLoadIdentity();
-        ((Buffer)this.viewportBuffer).clear();
-        GL11.glGetInteger(2978, this.viewportBuffer);
-        ((Buffer)this.viewportBuffer).flip();
-        ((Buffer)this.viewportBuffer).limit(16);
-        GLU.gluPickMatrix(x, y, 5.0F, 5.0F, this.viewportBuffer);
-        GLU.gluPerspective(70.0F, (float)this.width / this.height, 0.05F, 1000.0F);
-        GL11.glMatrixMode(5888);
+        this.viewportBuffer.clear();
+        GL11.glGetIntegerv(GL11.GL_VIEWPORT, this.viewportBuffer);
+        this.viewportBuffer.flip();
+        this.viewportBuffer.limit(16);
+        gluPickMatrix((float)x, (float)y, 5.0F, 5.0F, this.viewportBuffer);
+        gluPerspective(70.0F, (float)this.width / (float)this.height, 0.05F, 1000.0F);
+        GL11.glMatrixMode(GL11.GL_MODELVIEW);
         GL11.glLoadIdentity();
         this.moveCameraToPlayer(a);
     }
 
     private void pick(float a) {
-        ((Buffer)this.selectBuffer).clear();
+        this.selectBuffer.clear();
         GL11.glSelectBuffer(this.selectBuffer);
-        GL11.glRenderMode(7170);
+        GL11.glRenderMode(GL11.GL_SELECT);
         this.setupPickCamera(a, this.width / 2, this.height / 2);
         this.levelRenderer.pick(this.player);
-        int hits = GL11.glRenderMode(7168);
-        ((Buffer)this.selectBuffer).flip();
-        ((Buffer)this.selectBuffer).limit(this.selectBuffer.capacity());
+        int hits = GL11.glRenderMode(GL11.GL_RENDER);
+        this.selectBuffer.flip();
+        this.selectBuffer.limit(this.selectBuffer.capacity());
         long closest = 0L;
         int[] names = new int[10];
         int hitNameCount = 0;
 
         for (int i = 0; i < hits; i++) {
             int nameCount = this.selectBuffer.get();
-            long minZ = this.selectBuffer.get();
+            long minZ = (long)this.selectBuffer.get();
             this.selectBuffer.get();
             if (minZ >= closest && i != 0) {
                 for (int j = 0; j < nameCount; j++) {
@@ -178,82 +249,142 @@
     }
 
     public void render(float a) {
-        float xo = Mouse.getDX();
-        float yo = Mouse.getDY();
-        this.player.turn(xo, yo);
+        // Only apply mouse look when grabbed
+        if (mouseGrabbed) {
+            float xo = (float)mouseDX;
+            float yo = (float)mouseDY;
+            mouseDX = 0;
+            mouseDY = 0;
+            this.player.turn(xo, yo);
+        } else {
+            mouseDX = 0;
+            mouseDY = 0;
+        }
+
         this.pick(a);
 
-        while (Mouse.next()) {
-            if (Mouse.getEventButton() == 1 && Mouse.getEventButtonState() && this.hitResult != null) {
+        // Process mouse button events
+        while (!mouseEvents.isEmpty()) {
+            int[] event = mouseEvents.poll();
+            int button = event[0];
+            boolean pressed = event[1] == 1;
+
+            // Click to re-grab
+            if (!mouseGrabbed && pressed) {
+                grabMouse();
+                continue;
+            }
+
+            if (button == GLFW.GLFW_MOUSE_BUTTON_RIGHT && pressed && this.hitResult != null) {
                 this.level.setTile(this.hitResult.x, this.hitResult.y, this.hitResult.z, 0);
             }
 
-            if (Mouse.getEventButton() == 0 && Mouse.getEventButtonState() && this.hitResult != null) {
-                int x = this.hitResult.x;
-                int y = this.hitResult.y;
-                int z = this.hitResult.z;
+            if (button == GLFW.GLFW_MOUSE_BUTTON_LEFT && pressed && this.hitResult != null) {
+                int bx = this.hitResult.x;
+                int by = this.hitResult.y;
+                int bz = this.hitResult.z;
                 if (this.hitResult.f == 0) {
-                    y--;
+                    by--;
                 }
 
                 if (this.hitResult.f == 1) {
-                    y++;
+                    by++;
                 }
 
                 if (this.hitResult.f == 2) {
-                    z--;
+                    bz--;
                 }
 
                 if (this.hitResult.f == 3) {
-                    z++;
+                    bz++;
                 }
 
                 if (this.hitResult.f == 4) {
-                    x--;
+                    bx--;
                 }
 
                 if (this.hitResult.f == 5) {
-                    x++;
+                    bx++;
                 }
 
-                this.level.setTile(x, y, z, 1);
+                this.level.setTile(bx, by, bz, 1);
             }
         }
 
-        while (Keyboard.next()) {
-            if (Keyboard.getEventKey() == 28 && Keyboard.getEventKeyState()) {
+        // Process keyboard events
+        while (!keyEvents.isEmpty()) {
+            int[] event = keyEvents.poll();
+            int key = event[0];
+            boolean pressed = event[1] == 1;
+            int mods = event.length > 2 ? event[2] : 0;
+            if (key == GLFW.GLFW_KEY_ESCAPE && pressed) {
+                ungrabMouse();
+            }
+            if (key == GLFW.GLFW_KEY_Q && pressed && (mods & GLFW.GLFW_MOD_CONTROL) != 0) {
+                GLFW.glfwSetWindowShouldClose(window, true);
+            }
+            if (key == GLFW.GLFW_KEY_ENTER && pressed) {
                 this.level.save();
             }
         }
 
-        GL11.glClear(16640);
+        GL11.glClear(GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT);
         this.setupCamera(a);
-        GL11.glEnable(2884);
-        GL11.glEnable(2912);
-        GL11.glFogi(2917, 2048);
-        GL11.glFogf(2914, 0.2F);
-        GL11.glFog(2918, this.fogColor);
-        GL11.glDisable(2912);
+        GL11.glEnable(GL11.GL_CULL_FACE);
+        GL11.glEnable(GL11.GL_FOG);
+        GL11.glFogi(GL11.GL_FOG_MODE, GL11.GL_EXP2);
+        GL11.glFogf(GL11.GL_FOG_DENSITY, 0.2F);
+        GL11.glFogfv(GL11.GL_FOG_COLOR, this.fogColor);
+        GL11.glDisable(GL11.GL_FOG);
         this.levelRenderer.render(this.player, 0);
-        GL11.glEnable(2912);
+        GL11.glEnable(GL11.GL_FOG);
         this.levelRenderer.render(this.player, 1);
-        GL11.glDisable(3553);
+        GL11.glDisable(GL11.GL_TEXTURE_2D);
         if (this.hitResult != null) {
             this.levelRenderer.renderHit(this.hitResult);
         }
 
-        GL11.glDisable(2912);
-        Display.update();
+        GL11.glDisable(GL11.GL_FOG);
+        GLFW.glfwSwapBuffers(window);
+        GLFW.glfwPollEvents();
     }
 
     public static void checkError() {
         int e = GL11.glGetError();
         if (e != 0) {
-            throw new IllegalStateException(GLU.gluErrorString(e));
+            throw new IllegalStateException("OpenGL error: " + e);
         }
     }
 
-    public static void main(String[] args) throws LWJGLException {
+    // GLU replacements — LWJGL 3 removed the GLU utility library
+
+    private static void gluPerspective(float fovy, float aspect, float zNear, float zFar) {
+        float f = (float)(1.0 / Math.tan(Math.toRadians(fovy) / 2.0));
+        float rangeReciprocal = 1.0f / (zNear - zFar);
+
+        FloatBuffer matrix = BufferUtils.createFloatBuffer(16);
+        matrix.put(new float[]{
+            f / aspect, 0, 0, 0,
+            0, f, 0, 0,
+            0, 0, (zFar + zNear) * rangeReciprocal, -1,
+            0, 0, 2 * zFar * zNear * rangeReciprocal, 0
+        });
+        matrix.flip();
+        GL11.glMultMatrixf(matrix);
+    }
+
+    private static void gluPickMatrix(float x, float y, float deltaX, float deltaY, IntBuffer viewport) {
+        if (deltaX <= 0 || deltaY <= 0) return;
+
+        GL11.glTranslatef(
+            (viewport.get(2) - 2 * (x - viewport.get(0))) / deltaX,
+            (viewport.get(3) - 2 * (y - viewport.get(1))) / deltaY,
+            0
+        );
+        GL11.glScalef(viewport.get(2) / deltaX, viewport.get(3) / deltaY, 1.0f);
+    }
+
+    public static void main(String[] args) {
         new Thread(new RubyDung()).start();
     }
 }
diff -ruN /home/user/RDForward/rd-game/build/clean-src/com/mojang/rubydung/Textures.java /home/user/RDForward/rd-game/src/main/java/com/mojang/rubydung/Textures.java
--- a/com/mojang/rubydung/Textures.java	2026-02-11 10:47:30.708519983 +0000
+++ b/com/mojang/rubydung/Textures.java	2026-02-11 10:47:30.950519872 +0000
@@ -8,7 +8,7 @@
 import javax.imageio.ImageIO;
 import org.lwjgl.BufferUtils;
 import org.lwjgl.opengl.GL11;
-import org.lwjgl.util.glu.GLU;
+import org.lwjgl.opengl.GL30;
 
 public class Textures {
     private static HashMap<String, Integer> idMap = new HashMap<>();
@@ -23,8 +23,8 @@
                 GL11.glGenTextures(ib);
                 int id = ib.get(0);
                 bind(id);
-                GL11.glTexParameteri(3553, 10241, mode);
-                GL11.glTexParameteri(3553, 10240, mode);
+                GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER, mode);
+                GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MAG_FILTER, mode);
                 BufferedImage img = ImageIO.read(Textures.class.getResourceAsStream(resourceName));
                 int w = img.getWidth();
                 int h = img.getHeight();
@@ -41,7 +41,8 @@
                 }
 
                 pixels.asIntBuffer().put(rawPixels);
-                GLU.gluBuild2DMipmaps(3553, 6408, w, h, 6408, 5121, pixels);
+                GL11.glTexImage2D(GL11.GL_TEXTURE_2D, 0, GL11.GL_RGBA, w, h, 0, GL11.GL_RGBA, GL11.GL_UNSIGNED_BYTE, pixels);
+                GL30.glGenerateMipmap(GL11.GL_TEXTURE_2D);
                 return id;
             }
         } catch (IOException var14) {
@@ -51,7 +52,7 @@
 
     public static void bind(int id) {
         if (id != lastId) {
-            GL11.glBindTexture(3553, id);
+            GL11.glBindTexture(GL11.GL_TEXTURE_2D, id);
             lastId = id;
         }
     }
diff -ruN /home/user/RDForward/rd-game/build/clean-src/com/mojang/rubydung/Timer.java /home/user/RDForward/rd-game/src/main/java/com/mojang/rubydung/Timer.java
--- a/com/mojang/rubydung/Timer.java	2026-02-11 10:47:30.711519982 +0000
+++ b/com/mojang/rubydung/Timer.java	2026-02-11 10:47:30.951519871 +0000
@@ -36,7 +36,7 @@
             this.ticks = 100;
         }
 
-        this.passedTime = this.passedTime - this.ticks;
+        this.passedTime = this.passedTime - (float)this.ticks;
         this.a = this.passedTime;
     }
 }
diff -ruN /home/user/RDForward/rd-game/build/clean-src/com/mojang/rubydung/level/Chunk.java /home/user/RDForward/rd-game/src/main/java/com/mojang/rubydung/level/Chunk.java
--- a/com/mojang/rubydung/level/Chunk.java	2026-02-11 10:47:30.715519980 +0000
+++ b/com/mojang/rubydung/level/Chunk.java	2026-02-11 10:47:30.952519871 +0000
@@ -15,7 +15,7 @@
     public final int z1;
     private boolean dirty = true;
     private int lists = -1;
-    private static int texture = Textures.loadTexture("/terrain.png", 9728);
+    private static int texture = Textures.loadTexture("/terrain.png", GL11.GL_NEAREST);
     private static Tesselator t = new Tesselator();
     public static int rebuiltThisFrame = 0;
     public static int updates = 0;
@@ -28,7 +28,7 @@
         this.x1 = x1;
         this.y1 = y1;
         this.z1 = z1;
-        this.aabb = new AABB(x0, y0, z0, x1, y1, z1);
+        this.aabb = new AABB((float)x0, (float)y0, (float)z0, (float)x1, (float)y1, (float)z1);
         this.lists = GL11.glGenLists(2);
     }
 
@@ -37,9 +37,9 @@
             this.dirty = false;
             updates++;
             rebuiltThisFrame++;
-            GL11.glNewList(this.lists + layer, 4864);
-            GL11.glEnable(3553);
-            GL11.glBindTexture(3553, texture);
+            GL11.glNewList(this.lists + layer, GL11.GL_COMPILE);
+            GL11.glEnable(GL11.GL_TEXTURE_2D);
+            GL11.glBindTexture(GL11.GL_TEXTURE_2D, texture);
             t.init();
             int tiles = 0;
 
@@ -60,7 +60,7 @@
             }
 
             t.flush();
-            GL11.glDisable(3553);
+            GL11.glDisable(GL11.GL_TEXTURE_2D);
             GL11.glEndList();
         }
     }
diff -ruN /home/user/RDForward/rd-game/build/clean-src/com/mojang/rubydung/level/Frustum.java /home/user/RDForward/rd-game/src/main/java/com/mojang/rubydung/level/Frustum.java
--- a/com/mojang/rubydung/level/Frustum.java	2026-02-11 10:47:30.718519978 +0000
+++ b/com/mojang/rubydung/level/Frustum.java	2026-02-11 10:47:30.954519870 +0000
@@ -1,7 +1,6 @@
 package com.mojang.rubydung.level;
 
 import com.mojang.rubydung.phys.AABB;
-import java.nio.Buffer;
 import java.nio.FloatBuffer;
 import org.lwjgl.BufferUtils;
 import org.lwjgl.opengl.GL11;
@@ -35,7 +34,9 @@
     }
 
     private void normalizePlane(float[][] frustum, int side) {
-        float magnitude = (float)Math.sqrt(frustum[side][0] * frustum[side][0] + frustum[side][1] * frustum[side][1] + frustum[side][2] * frustum[side][2]);
+        float magnitude = (float)Math.sqrt(
+            (double)(frustum[side][0] * frustum[side][0] + frustum[side][1] * frustum[side][1] + frustum[side][2] * frustum[side][2])
+        );
         frustum[side][0] = frustum[side][0] / magnitude;
         frustum[side][1] = frustum[side][1] / magnitude;
         frustum[side][2] = frustum[side][2] / magnitude;
@@ -43,14 +44,14 @@
     }
 
     private void calculateFrustum() {
-        ((Buffer)this._proj).clear();
-        ((Buffer)this._modl).clear();
-        ((Buffer)this._clip).clear();
-        GL11.glGetFloat(2983, this._proj);
-        GL11.glGetFloat(2982, this._modl);
-        ((Buffer)this._proj).flip().limit(16);
+        this._proj.clear();
+        this._modl.clear();
+        this._clip.clear();
+        GL11.glGetFloatv(GL11.GL_PROJECTION_MATRIX, this._proj);
+        GL11.glGetFloatv(GL11.GL_MODELVIEW_MATRIX, this._modl);
+        this._proj.flip().limit(16);
         this._proj.get(this.proj);
-        ((Buffer)this._modl).flip().limit(16);
+        this._modl.flip().limit(16);
         this._modl.get(this.modl);
         this.clip[0] = this.modl[0] * this.proj[0] + this.modl[1] * this.proj[4] + this.modl[2] * this.proj[8] + this.modl[3] * this.proj[12];
         this.clip[1] = this.modl[0] * this.proj[1] + this.modl[1] * this.proj[5] + this.modl[2] * this.proj[9] + this.modl[3] * this.proj[13];
diff -ruN /home/user/RDForward/rd-game/build/clean-src/com/mojang/rubydung/level/Level.java /home/user/RDForward/rd-game/src/main/java/com/mojang/rubydung/level/Level.java
--- a/com/mojang/rubydung/level/Level.java	2026-02-11 10:47:30.720519978 +0000
+++ b/com/mojang/rubydung/level/Level.java	2026-02-11 10:47:30.955519870 +0000
@@ -40,7 +40,11 @@
 
     public void load() {
         try {
-            DataInputStream dis = new DataInputStream(new GZIPInputStream(new FileInputStream(new File("level.dat"))));
+            File levelFile = new File("level.dat");
+            if (!levelFile.exists()) {
+                return;
+            }
+            DataInputStream dis = new DataInputStream(new GZIPInputStream(new FileInputStream(levelFile)));
             dis.readFully(this.blocks);
             this.calcLightDepths(0, 0, this.width, this.height);
 
@@ -145,7 +149,7 @@
             for (int y = y0; y < y1; y++) {
                 for (int z = z0; z < z1; z++) {
                     if (this.isSolidTile(x, y, z)) {
-                        aABBs.add(new AABB(x, y, z, x + 1, y + 1, z + 1));
+                        aABBs.add(new AABB((float)x, (float)y, (float)z, (float)(x + 1), (float)(y + 1), (float)(z + 1)));
                     }
                 }
             }
diff -ruN /home/user/RDForward/rd-game/build/clean-src/com/mojang/rubydung/level/LevelRenderer.java /home/user/RDForward/rd-game/src/main/java/com/mojang/rubydung/level/LevelRenderer.java
--- a/com/mojang/rubydung/level/LevelRenderer.java	2026-02-11 10:47:30.724519976 +0000
+++ b/com/mojang/rubydung/level/LevelRenderer.java	2026-02-11 10:47:30.956519869 +0000
@@ -104,13 +104,13 @@
     }
 
     public void renderHit(HitResult h) {
-        GL11.glEnable(3042);
-        GL11.glBlendFunc(770, 1);
-        GL11.glColor4f(1.0F, 1.0F, 1.0F, (float)Math.sin(System.currentTimeMillis() / 100.0) * 0.2F + 0.4F);
+        GL11.glEnable(GL11.GL_BLEND);
+        GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE);
+        GL11.glColor4f(1.0F, 1.0F, 1.0F, (float)Math.sin((double)System.currentTimeMillis() / 100.0) * 0.2F + 0.4F);
         this.t.init();
         Tile.rock.renderFace(this.t, h.x, h.y, h.z, h.f);
         this.t.flush();
-        GL11.glDisable(3042);
+        GL11.glDisable(GL11.GL_BLEND);
     }
 
     public void setDirty(int x0, int y0, int z0, int x1, int y1, int z1) {
diff -ruN /home/user/RDForward/rd-game/build/clean-src/com/mojang/rubydung/level/Tesselator.java /home/user/RDForward/rd-game/src/main/java/com/mojang/rubydung/level/Tesselator.java
--- a/com/mojang/rubydung/level/Tesselator.java	2026-02-11 10:47:30.726519975 +0000
+++ b/com/mojang/rubydung/level/Tesselator.java	2026-02-11 10:47:30.956519869 +0000
@@ -1,6 +1,5 @@
 package com.mojang.rubydung.level;
 
-import java.nio.Buffer;
 import java.nio.FloatBuffer;
 import org.lwjgl.BufferUtils;
 import org.lwjgl.opengl.GL11;
@@ -20,35 +19,35 @@
     private boolean hasTexture = false;
 
     public void flush() {
-        ((Buffer)this.vertexBuffer).flip();
-        ((Buffer)this.texCoordBuffer).flip();
-        ((Buffer)this.colorBuffer).flip();
-        GL11.glVertexPointer(3, 0, this.vertexBuffer);
+        this.vertexBuffer.flip();
+        this.texCoordBuffer.flip();
+        this.colorBuffer.flip();
+        GL11.glVertexPointer(3, GL11.GL_FLOAT, 0, this.vertexBuffer);
         if (this.hasTexture) {
-            GL11.glTexCoordPointer(2, 0, this.texCoordBuffer);
+            GL11.glTexCoordPointer(2, GL11.GL_FLOAT, 0, this.texCoordBuffer);
         }
 
         if (this.hasColor) {
-            GL11.glColorPointer(3, 0, this.colorBuffer);
+            GL11.glColorPointer(3, GL11.GL_FLOAT, 0, this.colorBuffer);
         }
 
-        GL11.glEnableClientState(32884);
+        GL11.glEnableClientState(GL11.GL_VERTEX_ARRAY);
         if (this.hasTexture) {
-            GL11.glEnableClientState(32888);
+            GL11.glEnableClientState(GL11.GL_TEXTURE_COORD_ARRAY);
         }
 
         if (this.hasColor) {
-            GL11.glEnableClientState(32886);
+            GL11.glEnableClientState(GL11.GL_COLOR_ARRAY);
         }
 
-        GL11.glDrawArrays(7, 0, this.vertices);
-        GL11.glDisableClientState(32884);
+        GL11.glDrawArrays(GL11.GL_QUADS, 0, this.vertices);
+        GL11.glDisableClientState(GL11.GL_VERTEX_ARRAY);
         if (this.hasTexture) {
-            GL11.glDisableClientState(32888);
+            GL11.glDisableClientState(GL11.GL_TEXTURE_COORD_ARRAY);
         }
 
         if (this.hasColor) {
-            GL11.glDisableClientState(32886);
+            GL11.glDisableClientState(GL11.GL_COLOR_ARRAY);
         }
 
         this.clear();
@@ -56,9 +55,9 @@
 
     private void clear() {
         this.vertices = 0;
-        ((Buffer)this.vertexBuffer).clear();
-        ((Buffer)this.texCoordBuffer).clear();
-        ((Buffer)this.colorBuffer).clear();
+        this.vertexBuffer.clear();
+        this.texCoordBuffer.clear();
+        this.colorBuffer.clear();
     }
 
     public void init() {
diff -ruN /home/user/RDForward/rd-game/build/clean-src/com/mojang/rubydung/level/Tile.java /home/user/RDForward/rd-game/src/main/java/com/mojang/rubydung/level/Tile.java
--- a/com/mojang/rubydung/level/Tile.java	2026-02-11 10:47:30.728519974 +0000
+++ b/com/mojang/rubydung/level/Tile.java	2026-02-11 10:47:30.957519869 +0000
@@ -10,19 +10,19 @@
     }
 
     public void render(Tesselator t, Level level, int layer, int x, int y, int z) {
-        float u0 = this.tex / 16.0F;
+        float u0 = (float)this.tex / 16.0F;
         float u1 = u0 + 0.0624375F;
         float v0 = 0.0F;
         float v1 = v0 + 0.0624375F;
         float c1 = 1.0F;
         float c2 = 0.8F;
         float c3 = 0.6F;
-        float x0 = x + 0.0F;
-        float x1 = x + 1.0F;
-        float y0 = y + 0.0F;
-        float y1 = y + 1.0F;
-        float z0 = z + 0.0F;
-        float z1 = z + 1.0F;
+        float x0 = (float)x + 0.0F;
+        float x1 = (float)x + 1.0F;
+        float y0 = (float)y + 0.0F;
+        float y1 = (float)y + 1.0F;
+        float z0 = (float)z + 0.0F;
+        float z1 = (float)z + 1.0F;
         if (!level.isSolidTile(x, y - 1, z)) {
             float br = level.getBrightness(x, y - 1, z) * c1;
             if (br == c1 ^ layer == 1) {
@@ -115,12 +115,12 @@
     }
 
     public void renderFace(Tesselator t, int x, int y, int z, int face) {
-        float x0 = x + 0.0F;
-        float x1 = x + 1.0F;
-        float y0 = y + 0.0F;
-        float y1 = y + 1.0F;
-        float z0 = z + 0.0F;
-        float z1 = z + 1.0F;
+        float x0 = (float)x + 0.0F;
+        float x1 = (float)x + 1.0F;
+        float y0 = (float)y + 0.0F;
+        float y1 = (float)y + 1.0F;
+        float z0 = (float)z + 0.0F;
+        float z1 = (float)z + 1.0F;
         if (face == 0) {
             t.vertex(x0, y0, z1);
             t.vertex(x0, y0, z0);
