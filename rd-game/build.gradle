description = 'RDForward Game - Decompiled RubyDung with multiplayer patches'

// =============================================================================
// RubyDung BuildTools Configuration
// =============================================================================
// This module uses a Spigot BuildTools-style approach:
//   1. Download the original rd-132211.jar from Mojang CDN
//   2. Verify SHA1 integrity
//   3. Decompile with Vineflower
//   4. Apply patches from patches/ directory
//   5. Compile the patched source
//
// This avoids redistributing Mojang's copyrighted code. Only the patches
// (our modifications) are tracked in version control.
// =============================================================================

ext {
    rubyDungVersion = 'rd-132211'
    rubyDungSha1 = '393e8d4b4d708587e2accd7c5221db65365e1075'
    rubyDungUrl = "https://launcher.mojang.com/v1/objects/${rubyDungSha1}/client.jar"
    downloadDir = file("${buildDir}/download")
    decompileOutputDir = file("${buildDir}/decompiled")
    cleanSrcDir = file("${buildDir}/clean-src")
    generatedSrcDir = file('src/main/java')
    generatedResDir = file('src/main/resources')
    patchDir = file('patches')
    markerFile = file("${buildDir}/.workspace-ready")
}

// =============================================================================
// LWJGL 2.9.3 Dependencies
// =============================================================================
// Downloaded via curl (like Spigot BuildTools) to avoid Maven proxy issues.
// The JARs are cached in build/libs/ and gitignored.

ext {
    lwjglVersion = '2.9.3'
    mavenBase = 'https://repo.maven.apache.org/maven2/org/lwjgl/lwjgl'
    lwjglDir = file("${buildDir}/libs/lwjgl")
    lwjglJar = file("${lwjglDir}/lwjgl-${lwjglVersion}.jar")
    lwjglUtilJar = file("${lwjglDir}/lwjgl_util-${lwjglVersion}.jar")
}

def nativePlatform = {
    def os = System.getProperty('os.name').toLowerCase()
    if (os.contains('windows')) return 'natives-windows'
    if (os.contains('mac') || os.contains('darwin')) return 'natives-osx'
    return 'natives-linux'
}()

ext {
    lwjglNativesJar = file("${lwjglDir}/lwjgl-platform-${lwjglVersion}-${nativePlatform}.jar")
    // All platform native JARs (for the fat JAR distribution)
    allNativePlatforms = ['natives-windows', 'natives-linux', 'natives-osx']
    lwjglAllNativeJars = allNativePlatforms.collectEntries {
        [(it): file("${lwjglDir}/lwjgl-platform-${lwjglVersion}-${it}.jar")]
    }
}

task downloadLwjgl {
    description = 'Downloads LWJGL 2.9.3 JARs from Maven Central'
    group = 'buildtools'

    outputs.files(lwjglJar, lwjglUtilJar, lwjglNativesJar)

    doLast {
        lwjglDir.mkdirs()
        def downloads = [
            [lwjglJar,        "${mavenBase}/lwjgl/${lwjglVersion}/lwjgl-${lwjglVersion}.jar"],
            [lwjglUtilJar,    "${mavenBase}/lwjgl_util/${lwjglVersion}/lwjgl_util-${lwjglVersion}.jar"],
            [lwjglNativesJar, "${mavenBase}/lwjgl-platform/${lwjglVersion}/lwjgl-platform-${lwjglVersion}-${nativePlatform}.jar"],
        ]
        downloads.each { destFile, url ->
            if (!destFile.exists()) {
                logger.lifecycle("Downloading ${destFile.name}...")
                project.exec {
                    commandLine 'curl', '-fSL', '-o', destFile.absolutePath, url
                }
            }
        }
    }
}

dependencies {
    // LWJGL 2.9.3 - RubyDung's rendering engine (local files, downloaded by BuildTools)
    implementation files(lwjglJar, lwjglUtilJar)
}

// =============================================================================
// BuildTools Tasks
// =============================================================================

task downloadRubyDung {
    description = 'Downloads the original rd-132211 JAR from Mojang CDN'
    group = 'buildtools'

    def destFile = file("${downloadDir}/${rubyDungVersion}.jar")
    outputs.file(destFile)

    doLast {
        destFile.parentFile.mkdirs()
        if (!destFile.exists()) {
            logger.lifecycle("Downloading ${rubyDungVersion}.jar from Mojang CDN...")

            // Use curl for the download — it handles HTTP proxies, redirects,
            // and TLS more reliably than Java's URL class in diverse environments.
            project.exec {
                commandLine 'curl', '-fSL', '-o', destFile.absolutePath, rubyDungUrl
            }
        }

        // Verify SHA1
        def digest = java.security.MessageDigest.getInstance('SHA-1')
        def hash = digest.digest(destFile.bytes)
            .collect { String.format('%02x', it) }
            .join('')

        if (hash != rubyDungSha1) {
            destFile.delete()
            throw new GradleException(
                "SHA1 mismatch for ${rubyDungVersion}.jar!\n" +
                "  Expected: ${rubyDungSha1}\n" +
                "  Got:      ${hash}\n" +
                "The file has been deleted. Please re-run the task.")
        }
        logger.lifecycle("SHA1 verified: ${hash}")
    }
}

ext {
    vineflowerVersion = '1.11.2'
    vineflowerUrl = "https://repo.maven.apache.org/maven2/org/vineflower/vineflower/${vineflowerVersion}/vineflower-${vineflowerVersion}.jar"
    vineflowerJar = file("${buildDir}/tools/vineflower-${vineflowerVersion}.jar")
}

task downloadVineflower {
    description = 'Downloads the Vineflower decompiler'
    group = 'buildtools'

    outputs.file(vineflowerJar)

    doLast {
        vineflowerJar.parentFile.mkdirs()
        if (!vineflowerJar.exists()) {
            logger.lifecycle("Downloading Vineflower ${vineflowerVersion}...")
            project.exec {
                commandLine 'curl', '-fSL', '-o', vineflowerJar.absolutePath, vineflowerUrl
            }
        }
    }
}

task decompileRubyDung(type: JavaExec) {
    description = 'Decompiles rd-132211.jar using Vineflower'
    group = 'buildtools'
    dependsOn downloadRubyDung, downloadVineflower

    def inputJar = file("${downloadDir}/${rubyDungVersion}.jar")
    def outputDir = decompileOutputDir

    inputs.file(inputJar)
    outputs.dir(outputDir)

    classpath = files(vineflowerJar)
    mainClass = 'org.jetbrains.java.decompiler.main.decompiler.ConsoleDecompiler'

    // Vineflower options:
    //   -dgs=1  decompile generic signatures
    //   -asc=1  encode non-ASCII chars in string/char literals as escapes
    //   -rsy=1  remove synthetic class members
    //   -ind=   use 4-space indentation
    args = ['-dgs=1', '-asc=1', '-rsy=1', '-ind=    ',
            inputJar.absolutePath, outputDir.absolutePath]

    doFirst {
        outputDir.mkdirs()
    }
}

task extractCleanSources {
    description = 'Extracts decompiled sources as a clean reference copy (for patch generation)'
    group = 'buildtools'
    dependsOn decompileRubyDung

    doLast {
        if (cleanSrcDir.exists()) {
            delete cleanSrcDir
        }
        cleanSrcDir.mkdirs()

        // Vineflower outputs directly to the directory (not a JAR)
        copy {
            from(decompileOutputDir) {
                include '**/*.java'
            }
            into cleanSrcDir
        }
        logger.lifecycle("Extracted clean reference sources to ${cleanSrcDir}")
    }
}

task extractSources {
    description = 'Extracts decompiled sources into the source directory'
    group = 'buildtools'
    dependsOn decompileRubyDung

    doLast {
        // Only extract if source directory is empty or doesn't exist
        if (generatedSrcDir.exists() && generatedSrcDir.listFiles()?.length > 0) {
            logger.lifecycle("Source directory already populated, skipping extraction.")
            logger.lifecycle("To re-extract, delete ${generatedSrcDir} and re-run.")
            return
        }

        generatedSrcDir.mkdirs()

        // Vineflower outputs directly to the directory (not a JAR)
        copy {
            from(decompileOutputDir) {
                include '**/*.java'
            }
            into generatedSrcDir
        }
        logger.lifecycle("Extracted Java sources to ${generatedSrcDir}")
    }
}

task extractResources {
    description = 'Extracts resources (textures, etc.) from the decompiled output'
    group = 'buildtools'
    dependsOn decompileRubyDung

    doLast {
        // Only extract if resources directory is empty or doesn't exist
        if (generatedResDir.exists() && generatedResDir.listFiles()?.length > 0) {
            logger.lifecycle("Resources directory already populated, skipping extraction.")
            return
        }

        generatedResDir.mkdirs()

        // Copy non-Java resources from the decompile output
        copy {
            from(decompileOutputDir) {
                exclude '**/*.java'
            }
            into generatedResDir
        }
        logger.lifecycle("Extracted resources to ${generatedResDir}")
    }
}

task applyPatches {
    description = 'Applies patches from patches/ directory to the decompiled source'
    group = 'buildtools'
    dependsOn extractSources, extractCleanSources

    doLast {
        if (!patchDir.exists()) {
            logger.lifecycle("No patches directory found.")
            return
        }

        def patches = patchDir.listFiles()
            ?.findAll { it.name.endsWith('.patch') }
            ?.sort { it.name }

        if (!patches || patches.isEmpty()) {
            logger.lifecycle("No patches to apply.")
            return
        }

        patches.each { patch ->
            logger.lifecycle("Applying patch: ${patch.name}")
            def result = project.exec {
                workingDir generatedSrcDir
                commandLine 'patch', '-p1', '--forward', '-i', patch.absolutePath
                ignoreExitValue = true
            }
            if (result.exitValue != 0) {
                logger.warn("Patch ${patch.name} may have already been applied (exit code ${result.exitValue})")
            }
        }
        logger.lifecycle("Patch application complete.")
    }
}

task setupWorkspace {
    description = 'Full BuildTools pipeline: download, decompile, patch, and prepare workspace'
    group = 'buildtools'
    dependsOn applyPatches, extractResources

    doLast {
        markerFile.parentFile.mkdirs()
        markerFile.text = new Date().toString()

        logger.lifecycle('')
        logger.lifecycle('========================================')
        logger.lifecycle(' RDForward Workspace Setup Complete')
        logger.lifecycle('========================================')
        logger.lifecycle('')
        logger.lifecycle("  Game source:    ${generatedSrcDir}")
        logger.lifecycle("  Game resources: ${generatedResDir}")
        logger.lifecycle("  Clean sources:  ${cleanSrcDir}")
        logger.lifecycle('')
        logger.lifecycle('  Run the game:     ./gradlew :rd-game:runClient')
        logger.lifecycle('  Build all:        ./gradlew build')
        logger.lifecycle('  Rebuild patches:  ./gradlew :rd-game:rebuildPatches')
        logger.lifecycle('')
    }
}

// =============================================================================
// Patch Development Tasks
// =============================================================================

task rebuildPatches {
    description = 'Regenerates patch files from changes made to the decompiled source'
    group = 'buildtools'

    doLast {
        if (!cleanSrcDir.exists()) {
            throw new GradleException(
                "Clean source directory not found at ${cleanSrcDir}.\n" +
                "Run './gradlew :rd-game:setupWorkspace' first.")
        }

        if (!generatedSrcDir.exists()) {
            throw new GradleException(
                "Source directory not found at ${generatedSrcDir}.\n" +
                "Run './gradlew :rd-game:setupWorkspace' first.")
        }

        patchDir.mkdirs()

        // Generate unified diff between clean and modified sources
        def patchFile = file("${patchDir}/0001-rdforward-modifications.patch")
        def diffOutput = new ByteArrayOutputStream()

        def result = project.exec {
            commandLine 'diff', '-ruN',
                '--label', 'a/',
                '--label', 'b/',
                cleanSrcDir.absolutePath,
                generatedSrcDir.absolutePath
            standardOutput = diffOutput
            ignoreExitValue = true
        }

        if (result.exitValue == 0) {
            logger.lifecycle("No differences found between clean and modified sources.")
            if (patchFile.exists()) {
                patchFile.delete()
                logger.lifecycle("Removed empty patch file.")
            }
        } else if (result.exitValue == 1) {
            // diff returns 1 when files differ (normal)
            patchFile.text = diffOutput.toString()
            logger.lifecycle("Generated patch: ${patchFile.name} (${patchFile.length()} bytes)")
        } else {
            throw new GradleException("diff command failed with exit code ${result.exitValue}")
        }
    }
}

// =============================================================================
// Run Tasks
// =============================================================================

task extractNatives {
    description = 'Extracts LWJGL native libraries for the current platform'
    group = 'buildtools'
    dependsOn downloadLwjgl

    def nativeDir = file("${buildDir}/natives")
    outputs.dir(nativeDir)

    doLast {
        nativeDir.mkdirs()
        ant.unzip(src: lwjglNativesJar, dest: nativeDir) {
            patternset {
                exclude(name: 'META-INF/**')
            }
        }
        logger.lifecycle("Extracted LWJGL natives to ${nativeDir}")
    }
}

task runClient(type: JavaExec) {
    description = 'Launches the RubyDung game client'
    group = 'application'
    dependsOn classes, extractNatives

    classpath = sourceSets.main.runtimeClasspath
    mainClass = 'com.mojang.rubydung.RubyDung'
    jvmArgs = [
        "-Djava.library.path=${buildDir}/natives",
        '-Xmx512m'
    ]
}

// =============================================================================
// JAR Manifest
// =============================================================================

jar {
    manifest {
        attributes(
            'Main-Class': 'com.mojang.rubydung.RubyDung'
        )
    }
}

// =============================================================================
// Fat JAR Distribution
// =============================================================================
// Produces a single self-contained JAR that bundles LWJGL classes and native
// libraries for all platforms. Run with: java -jar rd-game-*-all.jar

sourceSets {
    launcher {
        java { srcDir 'src/launcher/java' }
        compileClasspath = sourceSets.main.output + files(lwjglJar, lwjglUtilJar)
    }
}

task downloadAllNatives {
    description = 'Downloads LWJGL native JARs for all platforms (Windows, Linux, macOS)'
    group = 'buildtools'
    dependsOn downloadLwjgl

    outputs.files(lwjglAllNativeJars.values())

    doLast {
        lwjglDir.mkdirs()
        lwjglAllNativeJars.each { platform, destFile ->
            if (!destFile.exists()) {
                logger.lifecycle("Downloading lwjgl-platform ${platform}...")
                project.exec {
                    commandLine 'curl', '-fSL', '-o', destFile.absolutePath,
                        "${mavenBase}/lwjgl-platform/${lwjglVersion}/lwjgl-platform-${lwjglVersion}-${platform}.jar"
                }
            }
        }
    }
}

task fatJar(type: Jar) {
    description = 'Builds a self-contained JAR with all dependencies and natives bundled'
    group = 'build'
    dependsOn classes, 'launcherClasses', downloadAllNatives

    archiveClassifier = 'all'

    manifest {
        attributes('Main-Class': 'com.github.martinambrus.rdforward.NativeLauncher')
    }

    // Game classes + resources
    from sourceSets.main.output
    // Launcher bootstrap
    from sourceSets.launcher.output
    // LWJGL Java libraries
    from(zipTree(lwjglJar)) { exclude 'META-INF/**' }
    from(zipTree(lwjglUtilJar)) { exclude 'META-INF/**' }
    // Native libraries for all platforms
    lwjglAllNativeJars.each { platform, nativeJar ->
        def platformName = platform.replace('natives-', '')
        from(zipTree(nativeJar)) {
            exclude 'META-INF/**'
            into "natives/${platformName}"
        }
    }

    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
}

// =============================================================================
// Build Integration
// =============================================================================

// Ensure workspace is set up before compilation.
// The setupWorkspace task is incremental — it skips steps whose outputs exist.
compileJava {
    dependsOn applyPatches, extractResources, downloadLwjgl
}

compileLauncherJava {
    dependsOn classes, downloadLwjgl
}

// Include generated sources in the sources JAR
tasks.named('sourcesJar') {
    dependsOn applyPatches
}

// Clean also removes generated sources and resources
clean.doFirst {
    delete generatedSrcDir
    delete generatedResDir
}
